#pragma once

#include "outliner_node.h"

#include "../Scene/scene_manager.h"

class outliner_manager_class{
public:

	outliner_manager_class(){
		root_node                     = new outliner_node_class;
		root_node->outliner_node_type = outliner_node_type_enum::root;

		// ---- test code here -----
		//add_new_node(root_node, outliner_node_type_enum::entity, ENTITY_CATEGORY_HCP_VOXEL);

		// -------------------------
	}
	
	~outliner_manager_class(){}


	scene_manager_class scene_manager;

	outliner_node_class *root_node = NULL;


	int current_selected_node = -1;

	void display_nodes(int vd = 0) {
		//int var = -1;
/*
		//int current_selected_node = -1;
		static int selection_mask = (1 << 2);
		//static ImGuiTreeNodeFlags base_flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_SpanAvailWidth;
		static ImGuiTreeNodeFlags base_flags = ImGuiTreeNodeFlags_DefaultOpen| ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_SpanAvailWidth;

		//if (ImGui::TreeNode("root")) {
		if(ImGui::TreeNodeEx((void*)(intptr_t)0, base_flags, "root", 0)){
			// Seems that Imgui requires all variables use need by ImGui widgets to be defined
			// within ImGui widget scope or will get a runtime error causing the app to crash !!!
			static bool align_label_with_current_x_position = false;
			static bool test_drag_and_drop = false;
			int node_clicked = -1;

			for (int i = 0; i < 6; i++)
			{
				ImGuiTreeNodeFlags node_flags = base_flags;
				const bool is_selected = (selection_mask & (1 << i)) != 0;
				if (is_selected)
					node_flags |= ImGuiTreeNodeFlags_Selected;

				bool node_open = ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags, "Selectable Node %d", i);
				if (ImGui::IsItemClicked() && !ImGui::IsItemToggledOpen()) {
					node_clicked = i;
					printf("display_nodes :: node_clicked : %i  \n",node_clicked); //this is the group
				}
				
				if (node_open) {
					node_flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen; // ImGuiTreeNodeFlags_Bullet
					for (int j = 0; j < 3; j++) {
						ImGui::TreeNodeEx((void*)(intptr_t)j, node_flags, "Selectable Leaf %d", j);
						if (ImGui::IsItemClicked() && !ImGui::IsItemToggledOpen()) {
							node_clicked = j;
							printf("display_nodes :: leaf_clicked : %i  \n", node_clicked); //this is the group
						}

					}ImGui::TreePop(); // Need a treepop at the end of each treenode definition
				}
			}ImGui::TreePop(); // Need a treepop at the end of each treenode definition
			
			if (ImGui::IsMouseDown(0) && ImGui::IsWindowHovered())
				var = -1;
				//current_selected_node = 1;

			// Right-click on blank space
			if (ImGui::BeginPopupContextWindow(0, 1, false)){
				if (ImGui::MenuItem("Create Empty Entity"))
					printf("display_nodes :: MenuItem selected  \n");
					//m_Context->CreateEntity("Empty Entity");

				ImGui::EndPopup();
			}

			//outliner_node_class *node = root_node;
			//for (int i = 0; i < node->children.size(); i++) {
			//	node->draw_node();
			//}
		}
*/
		current_selected_node = -1;

	}

	bool add_new_node(outliner_node_class *parent_node, outliner_node_type_enum outliner_node_type,category_id_type category_id) {
		switch (outliner_node_type) {
			case outliner_node_type_enum::group  : {return add_new_group(parent_node); break;}
			case outliner_node_type_enum::entity : {return add_new_entity(parent_node, category_id); break;}
		}

		return false;
	}

	bool delete_node() {

	}

	bool insert_node() {

	}

	void clear_scene() {

	}

	void delete_selected_nodes() {

	}

	bool import_scene() {

	}

	bool add_scene() {

	}


private:
	bool add_new_group(outliner_node_class *parent_node){
		outliner_node_class* new_outliner_node = new outliner_node_class(parent_node);
		if (new_outliner_node == NULL) {
			// error message
			return false;
		}

		new_outliner_node->outliner_node_type = outliner_node_type_enum::group;

		parent_node = new_outliner_node;
		parent_node->children.push_back(new_outliner_node);
		return true;
	}

	bool add_new_entity(outliner_node_class *parent_node, category_id_type category_id) {
		outliner_node_class *new_outliner_node = new outliner_node_class(parent_node);
		if (new_outliner_node == NULL) {
			// error message
			return false;
		}

		new_outliner_node->category_id = category_id;

		parent_node = new_outliner_node;
		parent_node->children.push_back(new_outliner_node);
		return true;
	}

};